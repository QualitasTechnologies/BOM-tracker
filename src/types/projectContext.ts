// Project Context Types (Transcript Intelligence System)
// Like CLAUDE.md but for each project - stores context for AI extraction

// ============================================
// Context Data Structure
// ============================================

export interface ProjectContextOwner {
  name: string;
  role: 'lead' | 'support' | 'reviewer';
  userId?: string;
}

export interface ProjectContextVendor {
  name: string;
  context?: string; // e.g., "PC supplier", "cameras and lights"
}

export interface ProjectContextLearned {
  term: string;           // What was mentioned: "Somotec PC"
  means: 'this project';  // Always means this project
  learnedOn: string;      // ISO date
  learnedBy?: string;     // User who made the correction
}

export interface ProjectContextData {
  project: string;        // Project name
  client: string;         // Client name
  aliases: string[];      // Alternative names used in meetings
  owners: ProjectContextOwner[];
  vendors: ProjectContextVendor[];
  keywords: string[];     // Domain terms that indicate this project
  learned: ProjectContextLearned[];
}

// ============================================
// Firestore Document Structure
// ============================================

export interface ProjectContext {
  id: string;             // Same as projectId
  projectId: string;

  // The context as editable YAML-like text
  content: string;

  // Parsed data for quick access (synced with content)
  parsedData: ProjectContextData;

  // Metadata
  autoGenerated: boolean;
  lastModified: string;   // ISO date
  modifiedBy?: string;    // User ID
  createdAt: string;      // ISO date
}

// ============================================
// Helper Functions
// ============================================

/**
 * Generate YAML-like context content from parsed data
 */
export function generateContextContent(data: ProjectContextData): string {
  const lines: string[] = [
    `# Project Context: ${data.project}`,
    `# Auto-generated from BOM Tracker. Edit as needed.`,
    `# Last updated: ${new Date().toISOString().split('T')[0]}`,
    ``,
    `project: ${data.project}`,
    `client: ${data.client}`,
    ``,
  ];

  // Aliases
  if (data.aliases.length > 0) {
    lines.push(`aliases:`);
    data.aliases.forEach(alias => {
      lines.push(`  - ${alias}`);
    });
    lines.push(``);
  }

  // Owners
  if (data.owners.length > 0) {
    lines.push(`owners:`);
    data.owners.forEach(owner => {
      lines.push(`  - name: ${owner.name}`);
      lines.push(`    role: ${owner.role}`);
    });
    lines.push(``);
  }

  // Vendors
  if (data.vendors.length > 0) {
    lines.push(`vendors:`);
    data.vendors.forEach(vendor => {
      lines.push(`  - name: ${vendor.name}`);
      if (vendor.context) {
        lines.push(`    context: ${vendor.context}`);
      }
    });
    lines.push(``);
  }

  // Keywords
  if (data.keywords.length > 0) {
    lines.push(`keywords:`);
    data.keywords.forEach(keyword => {
      lines.push(`  - ${keyword}`);
    });
    lines.push(``);
  }

  // Learned (corrections)
  if (data.learned.length > 0) {
    lines.push(`# Learned from corrections`);
    lines.push(`learned:`);
    data.learned.forEach(item => {
      lines.push(`  - term: "${item.term}"`);
      lines.push(`    means: ${item.means}`);
      lines.push(`    learned_on: ${item.learnedOn}`);
    });
    lines.push(``);
  }

  return lines.join('\n');
}

/**
 * Parse YAML-like context content into structured data
 */
export function parseContextContent(content: string): ProjectContextData {
  const data: ProjectContextData = {
    project: '',
    client: '',
    aliases: [],
    owners: [],
    vendors: [],
    keywords: [],
    learned: [],
  };

  const lines = content.split('\n');
  let currentSection: string | null = null;
  let currentItem: Record<string, string> = {};

  for (const line of lines) {
    const trimmed = line.trim();

    // Skip comments and empty lines
    if (trimmed.startsWith('#') || trimmed === '') {
      continue;
    }

    // Top-level key: value
    const keyValueMatch = trimmed.match(/^(\w+):\s*(.+)?$/);
    if (keyValueMatch && !trimmed.startsWith('-') && !trimmed.startsWith(' ')) {
      const [, key, value] = keyValueMatch;

      if (value) {
        // Simple key: value
        if (key === 'project') data.project = value;
        if (key === 'client') data.client = value;
      } else {
        // Section start (aliases:, owners:, etc.)
        currentSection = key;
        currentItem = {};
      }
      continue;
    }

    // List item: - value or - key: value
    if (trimmed.startsWith('-')) {
      // Save previous item if exists
      if (Object.keys(currentItem).length > 0) {
        saveCurrentItem(data, currentSection, currentItem);
        currentItem = {};
      }

      const listMatch = trimmed.match(/^-\s*(.+)$/);
      if (listMatch) {
        const itemContent = listMatch[1];

        // Check if it's a key: value pair
        const itemKeyValue = itemContent.match(/^(\w+):\s*(.+)$/);
        if (itemKeyValue) {
          const [, itemKey, itemValue] = itemKeyValue;
          currentItem[itemKey] = itemValue.replace(/^["']|["']$/g, ''); // Remove quotes
        } else {
          // Simple list item
          if (currentSection === 'aliases') data.aliases.push(itemContent);
          if (currentSection === 'keywords') data.keywords.push(itemContent);
        }
      }
      continue;
    }

    // Nested key: value (indented)
    const nestedMatch = trimmed.match(/^(\w+):\s*(.+)$/);
    if (nestedMatch && currentSection) {
      const [, key, value] = nestedMatch;
      currentItem[key] = value.replace(/^["']|["']$/g, ''); // Remove quotes
    }
  }

  // Save last item
  if (Object.keys(currentItem).length > 0) {
    saveCurrentItem(data, currentSection, currentItem);
  }

  return data;
}

function saveCurrentItem(
  data: ProjectContextData,
  section: string | null,
  item: Record<string, string>
): void {
  if (!section) return;

  switch (section) {
    case 'owners':
      if (item.name) {
        data.owners.push({
          name: item.name,
          role: (item.role as ProjectContextOwner['role']) || 'support',
        });
      }
      break;
    case 'vendors':
      if (item.name) {
        data.vendors.push({
          name: item.name,
          context: item.context,
        });
      }
      break;
    case 'learned':
      if (item.term) {
        data.learned.push({
          term: item.term,
          means: 'this project',
          learnedOn: item.learned_on || new Date().toISOString().split('T')[0],
        });
      }
      break;
  }
}

/**
 * Validate context content syntax
 */
export function validateContextContent(content: string): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  try {
    const parsed = parseContextContent(content);

    if (!parsed.project) {
      errors.push('Missing required field: project');
    }
    if (!parsed.client) {
      errors.push('Missing required field: client');
    }
  } catch (e) {
    errors.push(`Parse error: ${e instanceof Error ? e.message : 'Unknown error'}`);
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}
