// Project Context Firestore Operations
// Manages context files for transcript intelligence

import { db } from '@/firebase';
import {
  collection,
  doc,
  getDoc,
  getDocs,
  setDoc,
  updateDoc,
  deleteDoc,
  onSnapshot,
  Unsubscribe,
} from 'firebase/firestore';
import type {
  ProjectContext,
  ProjectContextData,
  ProjectContextVendor,
  ProjectContextLearned,
} from '@/types/projectContext';
import { generateContextContent, parseContextContent } from '@/types/projectContext';
import type { Project } from '@/utils/projectFirestore';
import type { BOMItem } from '@/types/bom';

const projectContextsCol = collection(db, 'projectContexts');

// ============================================
// CRUD Operations
// ============================================

/**
 * Get a project's context file
 */
export async function getProjectContext(projectId: string): Promise<ProjectContext | null> {
  const docRef = doc(projectContextsCol, projectId);
  const snapshot = await getDoc(docRef);

  if (!snapshot.exists()) {
    return null;
  }

  return { id: snapshot.id, ...snapshot.data() } as ProjectContext;
}

/**
 * Get all project contexts
 */
export async function getAllProjectContexts(): Promise<ProjectContext[]> {
  const snapshot = await getDocs(projectContextsCol);
  return snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() } as ProjectContext));
}

/**
 * Subscribe to a project's context (real-time)
 */
export function subscribeToProjectContext(
  projectId: string,
  callback: (context: ProjectContext | null) => void
): Unsubscribe {
  const docRef = doc(projectContextsCol, projectId);
  return onSnapshot(docRef, (snapshot) => {
    if (!snapshot.exists()) {
      callback(null);
      return;
    }
    callback({ id: snapshot.id, ...snapshot.data() } as ProjectContext);
  });
}

/**
 * Save or update a project's context file
 */
export async function saveProjectContext(
  projectId: string,
  content: string,
  userId?: string
): Promise<void> {
  const docRef = doc(projectContextsCol, projectId);
  const parsedData = parseContextContent(content);
  const now = new Date().toISOString();

  const existing = await getDoc(docRef);

  if (existing.exists()) {
    await updateDoc(docRef, {
      content,
      parsedData,
      autoGenerated: false, // Manual edit
      lastModified: now,
      modifiedBy: userId,
    });
  } else {
    const newContext: Omit<ProjectContext, 'id'> = {
      projectId,
      content,
      parsedData,
      autoGenerated: false,
      lastModified: now,
      modifiedBy: userId,
      createdAt: now,
    };
    await setDoc(docRef, newContext);
  }
}

/**
 * Delete a project's context file
 */
export async function deleteProjectContext(projectId: string): Promise<void> {
  const docRef = doc(projectContextsCol, projectId);
  await deleteDoc(docRef);
}

// ============================================
// Auto-Generation
// ============================================

/**
 * Auto-generate context from project and BOM data
 */
export async function generateProjectContext(
  project: Project,
  bomItems: BOMItem[],
  ownerName?: string
): Promise<ProjectContext> {
  const now = new Date().toISOString();

  // Extract unique vendors from BOM items
  const vendorMap = new Map<string, ProjectContextVendor>();
  bomItems.forEach((item) => {
    if (item.finalizedVendor?.name && !vendorMap.has(item.finalizedVendor.name)) {
      vendorMap.set(item.finalizedVendor.name, {
        name: item.finalizedVendor.name,
        context: item.category || undefined,
      });
    }
  });

  // Extract keywords from categories and item names
  const keywordSet = new Set<string>();
  bomItems.forEach((item) => {
    if (item.category) {
      keywordSet.add(item.category.toLowerCase());
    }
  });

  // Build aliases (project name, client name - deduplicated)
  const aliases: string[] = [];
  if (project.projectName) aliases.push(project.projectName);
  if (project.clientName && project.clientName !== project.projectName) {
    aliases.push(project.clientName);
  }

  // Build owners list
  const owners = [];
  if (ownerName) {
    owners.push({ name: ownerName, role: 'lead' as const });
  }

  // Build context data
  const parsedData: ProjectContextData = {
    project: project.projectName,
    client: project.clientName,
    aliases,
    owners,
    vendors: Array.from(vendorMap.values()),
    keywords: Array.from(keywordSet),
    learned: [], // Start empty, will accumulate from corrections
  };

  // Generate content
  const content = generateContextContent(parsedData);

  return {
    id: project.projectId,
    projectId: project.projectId,
    content,
    parsedData,
    autoGenerated: true,
    lastModified: now,
    createdAt: now,
  };
}

/**
 * Auto-generate and save context for a project
 */
export async function autoGenerateAndSaveContext(
  project: Project,
  bomItems: BOMItem[],
  ownerName?: string,
  preserveLearned: boolean = true
): Promise<ProjectContext> {
  // Check for existing context to preserve learned items
  let existingLearned: ProjectContextLearned[] = [];
  if (preserveLearned) {
    const existing = await getProjectContext(project.projectId);
    if (existing) {
      existingLearned = existing.parsedData.learned || [];
    }
  }

  // Generate new context
  const context = await generateProjectContext(project, bomItems, ownerName);

  // Preserve learned items
  if (existingLearned.length > 0) {
    context.parsedData.learned = existingLearned;
    context.content = generateContextContent(context.parsedData);
  }

  // Save to Firestore
  const docRef = doc(projectContextsCol, project.projectId);
  await setDoc(docRef, {
    projectId: context.projectId,
    content: context.content,
    parsedData: context.parsedData,
    autoGenerated: true,
    lastModified: context.lastModified,
    createdAt: context.createdAt,
  });

  return context;
}

// ============================================
// Learning from Corrections
// ============================================

/**
 * Add a learned term to a project's context
 */
export async function addLearnedTerm(
  projectId: string,
  term: string,
  userId?: string
): Promise<void> {
  const context = await getProjectContext(projectId);
  if (!context) {
    throw new Error(`No context found for project ${projectId}`);
  }

  // Check if term already learned
  const alreadyLearned = context.parsedData.learned.some(
    (l) => l.term.toLowerCase() === term.toLowerCase()
  );
  if (alreadyLearned) {
    return; // Already knows this term
  }

  // Add new learned item
  const newLearned: ProjectContextLearned = {
    term,
    means: 'this project',
    learnedOn: new Date().toISOString().split('T')[0],
    learnedBy: userId,
  };

  context.parsedData.learned.push(newLearned);

  // Regenerate content with new learned item
  const content = generateContextContent(context.parsedData);

  // Update Firestore
  const docRef = doc(projectContextsCol, projectId);
  await updateDoc(docRef, {
    content,
    parsedData: context.parsedData,
    lastModified: new Date().toISOString(),
    modifiedBy: userId,
  });
}

/**
 * Add a vendor to a project's context
 */
export async function addVendorToContext(
  projectId: string,
  vendorName: string,
  vendorContext?: string,
  userId?: string
): Promise<void> {
  const context = await getProjectContext(projectId);
  if (!context) {
    throw new Error(`No context found for project ${projectId}`);
  }

  // Check if vendor already exists
  const alreadyExists = context.parsedData.vendors.some(
    (v) => v.name.toLowerCase() === vendorName.toLowerCase()
  );
  if (alreadyExists) {
    return;
  }

  // Add vendor
  context.parsedData.vendors.push({
    name: vendorName,
    context: vendorContext,
  });

  // Regenerate content
  const content = generateContextContent(context.parsedData);

  // Update Firestore
  const docRef = doc(projectContextsCol, projectId);
  await updateDoc(docRef, {
    content,
    parsedData: context.parsedData,
    lastModified: new Date().toISOString(),
    modifiedBy: userId,
  });
}

// ============================================
// Prompt Building
// ============================================

/**
 * Build consolidated prompt from all project contexts
 */
export async function buildContextPrompt(): Promise<string> {
  const contexts = await getAllProjectContexts();

  if (contexts.length === 0) {
    return '(No project contexts available)';
  }

  const lines: string[] = ['PROJECTS:', '---------'];

  // Build vendor to project mapping
  const vendorToProject = new Map<string, string[]>();

  contexts.forEach((ctx) => {
    const data = ctx.parsedData;

    // Project header
    lines.push(`${data.project} (Client: ${data.client})`);

    // Owners
    if (data.owners.length > 0) {
      const ownerStr = data.owners.map((o) => `${o.name} (${o.role})`).join(', ');
      lines.push(`  Owners: ${ownerStr}`);
    }

    // Aliases
    if (data.aliases.length > 0) {
      lines.push(`  Also known as: ${data.aliases.join(', ')}`);
    }

    // Vendors
    if (data.vendors.length > 0) {
      const vendorStr = data.vendors
        .map((v) => (v.context ? `${v.name} (${v.context})` : v.name))
        .join(', ');
      lines.push(`  Vendors: ${vendorStr}`);

      // Track vendor → project mapping
      data.vendors.forEach((v) => {
        const projects = vendorToProject.get(v.name) || [];
        projects.push(data.project);
        vendorToProject.set(v.name, projects);
      });
    }

    // Keywords
    if (data.keywords.length > 0) {
      lines.push(`  Keywords: ${data.keywords.join(', ')}`);
    }

    // Learned terms
    if (data.learned.length > 0) {
      const learnedStr = data.learned.map((l) => `"${l.term}"`).join(', ');
      lines.push(`  Remember: ${learnedStr} → this project`);
    }

    lines.push('');
  });

  // Add vendor mapping section
  if (vendorToProject.size > 0) {
    lines.push('KNOWN VENDORS (NOT projects - attribute to their project):');
    vendorToProject.forEach((projects, vendor) => {
      lines.push(`- ${vendor} → ${projects.join(', ')}`);
    });
    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Get all project names for the extraction function
 */
export async function getProjectNamesForExtraction(): Promise<string[]> {
  const contexts = await getAllProjectContexts();

  const names = new Set<string>();

  contexts.forEach((ctx) => {
    // Add project name
    names.add(ctx.parsedData.project);
    // Add aliases
    ctx.parsedData.aliases.forEach((alias) => names.add(alias));
  });

  return Array.from(names);
}
